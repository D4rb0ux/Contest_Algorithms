//Учёные с планеты Нибиру уже несколько десятилетий трудятся над созданием двигателя, который позволит космическим кораблям попадать в гиперпространство и двигаться там со сверхсветовой скоростью. Чтобы проверить, верны ли их представления о свойствах гиперпространства, учёные разработали следующий эксперимент.
//В гиперпространство помещают цепочку из n частиц, позиции в которой пронумерованы от 1 до n. Изначально i-я частица имеет заряд ai.
//Согласно современной теории, если на частицу с номером i попадает специальное излучение мощности d, по гиперпространству распространяются колебания, которые увеличивают на d заряд частиц под номерами i, 2i, 3i и т. д. (то есть под номерами, которые делятся на i).
//С помощью специального прибора учёные могут направить излучение одинаковой мощности на отрезок соседних частиц. Например, пусть изначально было 6 частиц с нулевыми зарядами, и учёные направили излучение мощности 5 на частицы с номерами 2 и 3. Тогда заряд частиц с номерами 2, 3, 4 повысится до пяти, а заряд частицы с номером 6 — до десяти (колебания настигнут её дважды). Заряд остальных частиц не изменится.
//Без воздействия прибора заряд частиц в эксперименте меняться не может.
//В течение эксперимента учёные планируют выполнять действия следующих типов:
//Измерить текущий заряд частицы с номером i.
//Направить излучение мощности d на частицы с номерами от l до r включительно.
//Вашей программе будет дан список выполненных действий. На каждое действие первого типа она должна выдать ожидаемый заряд частицы, рассчитанный согласно современной теории, описанной выше.
//Если ожидаемый заряд частиц совпадёт с зарядом, измеренным во время эксперимента, представления учёных о природе гиперпространства окажутся верными, и они смогут приступить к постройке гипердвигателей. Тогда всего через несколько лет жители Нибиру наконец-то встретятся со своими братьями с Земли!

#include <cmath>
#include <iostream>
#include <vector>

using namespace std;

size_t added_val(vector<size_t>& block, vector<size_t>& tail, size_t& n, size_t& position) {
    size_t sqrt_n = sqrt(n);
    size_t num_of_block = ceil(double(position) / sqrt_n);
    return block[num_of_block] + tail[position];
}

int main() {
    size_t n;
    cin >> n;
    size_t sqrt_n = sqrt(n);
    vector<size_t> block(300001);
    vector<size_t> tail(300001);
    vector<size_t > arr(300001);
    size_t m, command, elem_i, left, right, d, left_block, right_block, elem_val;
    for (size_t i = 0; i < n; i++)
        cin >> arr[i + 1];
    cin >> m;
    for (size_t i = 0; i < m; i++) {
        cin >> command;
        if (command == 2) {
            cin >> left >> right >> d;
            left_block = ceil(double(left) / sqrt_n);
            right_block = ceil(double(right) / sqrt_n);
            // если left и right находятся в одном блоке
            if (left_block == right_block) {
                for (size_t j = left; j <= right; j++)
                    tail[j] += d;
            } else {
            // вручную увеличиваем "хвосты" слева и справа, а также увеличиваем полноценные блоки
                for (size_t j = left; j <= left_block * sqrt_n; j++)
                    tail[j] += d;
                for (size_t j = left_block + 1; j <= right_block - 1; j++)
                    block[j] += d;
                for (size_t j = (right_block - 1) * sqrt_n + 1; j <= right; j++)
                    tail[j] += d;
            }
        }
        if (command == 1) {
            cin >> elem_i;
            elem_val = arr[elem_i];
            for (size_t j = 1; j*j <= elem_i; j++) {
            // если нашли делитель, ищем парный ему и прибавляем нужное добавленное значение к обоим
                if (elem_i % j == 0 && j*j != elem_i) {
                    size_t jj = elem_i / j;
                    elem_val += added_val(block, tail, n, j) + added_val(block, tail, n, jj);
                } else if (elem_i % j == 0 && j*j == elem_i) {
                    elem_val += added_val(block, tail, n, j);
                }
            }
            cout << elem_val << endl;
        }
    }
}
